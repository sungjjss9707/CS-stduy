가상 메모리(Virtual Momory)

  현재 실행중인 코드는 반드시 물리 메모리에 존재해야한다고 생각할 수 있다.
  하지만 모든 코드를 늘 물리 메모리에 올려놓을 필요는 없으며, 그렇게 한다고 할지라도 물리 메모리 크기는 제한적이기 때문에 불가능할 수도 있다.
  이를 해결하기 위해 가상 메모리를 사용한다. 
  가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것. 
  프로그램 중 당장 필요한 일부만을 물리 메모리에 올려놓고 실행하는 것
  가상주소는 메모리관리장치(MMU)에 의해 실제 주소로 변횐되며, 이덕분에 사용자는 실제주소를 의식x 
  가상메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어있는 '페이지 테이블' 로 관리됨
  이때 속도 향상을 위해 TLB를 씀
      TLB : 메모리과 CPU사이의 캐시의 한 종류. 페이지 테이블에 있는 리스트를 보관해서 CPU 가 페이지 테이블까지 직접 안가게끔 함.
  
  이점
      프로그램은 물리 메모리 크기에 제약받지 않을 수 있다. 프로그래머들은 매우 큰 가상 주소 공간을 가정하고 프로그래밍을 할 수 있다.
      각 프로그램의 코드 중 일부만이 메모리를 차지하므로 더 많은 프로그램이 동시에 수행될 수 있다. 이는 응답시간의 감소와 CPU 이용률 및 처리율을 향상시킨다.
      프로그램을 메모리에 올리고 스왑할 때 발생하는 입/출력 비용이 감소한다
      페이지 공유를 통해 파일이나 메모리가 둘 이상의 프로세스들에 의해 공유되는 것이 가능. 
  
  페이징
      메모리를 페이지 라는 고정 크기 형태로 블럭화하여 운용. 
      페이지의 총 크기는 곧 가상메모리 공간의 크기가 되는데, 만약에 이 크기가 메모리 공간보다 클 경우 남는부분을 하드에 저장한다. 
      이때 메모리와 하드간에 페이지를 교체해가면서 쓰는걸 스와핑이라고 한다.
      
  스와핑
      만약 가상 메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생한다.
      이때 메모리에서 당장 사용하지 않는 영역을 하드로 옮기고, 하드에서 일부분을 마치 메모리에서 불러와 쓰는 것을 스와핑이라고 한다. 
      이를 통해서 마치 페이지 폴트가 일어나지 않은듯 보이게 한다.
  
  페이지 폴트
      프로세스의 주소공간에는 존재하지만, 실제 RAM에는 없는 데이터에 접근하는 경우.
          1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생하여 OS에게 알림
          2. OS는 CPU의 동작을 잠시 멈춤
          3. OS는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 찾고, 없으면 프로세스를 잠시 중단. 이때 스와핑 발동
          4. 하드에서와 메모리 사이에 스와핑이 발동하고, 페이지 테이블 최신화
          5. 중단되었던 CPU재시작
  
  요구 페이징
      일반적인 가상 메모리는 보통 요구 페이징으로 구현한다.
      요구 페이징은 프로그램 실행 시 모든 부분을 메모리에 적재하는 것이 아니라, 실행 과정에서 페이지를 요구할 때마다, 즉 페이지들이 필요해질 때마다 적재하는 전략
      요구 페이징은 스와핑과 개념이 유사하다. 스와핑에서는 보조 메모리의(하드) 프로세스를 실행하고 싶을 때에 주 메모리로 읽어옴(swap in).
      이와 같이 프로세스 내 페이지를 관리하는 페이저(pager)는 프로세스가 스왑 아웃(swap out)되기 전에 실제로 사용될 페이지가 어떤 것일지 추측하고, 
      이후에는 프로세스 전체를 스왑인 하는 대신 실제 필요한 페이지만 메모리로 읽어온다. 
      이를 위해서는 하드웨어 적인 기술이 필요한데, 유효/무효 비트를 사용하여 페이지가 메모리에 존재할 경우 유효(valid)하다고 표시하고, 
      페이지가 가상 주소 공간에 정의되지 않았거나 디스크에 존재할 경우 무효(invalid)하다고 표시하거나 페이지가 현재 저장된 디스크 주소를 기록한다.
      
      순수 요구 페이징 : 특정 페이지가 필요해 실제로 참조하기 전에는 절대 그 페이지를 메모리로 적재하지 않는 방법
          이를 통해 전체 프로세스가 주 메모리에 올라와있지 않아도 프로세스를 실행할 수 있다.
          메커니즘은 다음과 같다.
              1. 실제로 참조하지 않는 페이지는 초기에 메모리에 올리지 않으므로 어떤 페이지도 메모리에 올라가 있지 않음
              2. 특정 페이지에 대한 참조가 발생
              3. 페이지 부재(page fault) 발생
              4. 운영체제는 내부 테이블을 통해 해당 페이지가 디스크 내부 어디에 위치했는지 파악
              5. 자유 프레임을 탐색하여 디스크로부터 해당 페이지를 읽어옴
              6. 페이지 테이블 내애 페이지에 변화가 생겼음을 표시
              7. 3에서 페이지 부재로 중지되었던 명령이 다시 실행됨
          위에서 볼 수 있듯이 요구 페이징의 성능은 페이지 부재에 의해 좌우됨. 따라서 페이지 부재율을 낮게 유지하는 것이 중요하다.
          
          페이지 교체 알고리즘
               실제 시스템이 보유한 페이지보다 더 많은 프로세스가 더 많은 페이지를 요구할 경우, 페이지 간 교체를 해야하는 문제가 발생
               1. FIFO 페이지 교체(First-In-First-Out)
                   메모리에 올라온 페이지 중 가장 오래된 페이지를 교체하는 방법
                   페이지가 올라온 시간을 기록하거나, 페이지가 올라온 순서대로 큐(queue)를 생성하여 관리
                   가장 직관적이고 단순하지만 성능이 좋지않음
               2. 최적 페이지 교체(OPT, Optimal page replacement)
                   앞으로 가장 오랜 동안 사용되지 않을 페이지를 찾아 교체하는 방법
                   장점 : 가장 낮은 페이지 부재율을 보장하는 최적의 알고리즘
                   단점 : 실제 구현이 거의 불가능
               3. LRU 페이지 교체(Least-Recently-Used)
                   가장 오랜 기간 동안 사용되지 않은 페이지를 교체하는 방법
                   최적 알고리즘의 근사 알고리즘으로 최근의 과거를 가까운 미래의 근사치로 생각
                   각 페이지마다 마지막 사용 시간을 기록하여 구현
                   장점 : OPT와 근사하게 좋은 성능을 보장
                   단점 : 카운터나 스택과 같은 구현을 위해 하드웨어 지원이 필요함
               4. LRU 근사 페이지 교체(LRU Approximation)
                   하드웨어의 지원을 필요로하는 LRU 페이지 교체 알고리즘의 한계를 극복하기 위한 알고리즘
               5. 계수 기반 페이지 교체(Counting-Based)
                     LFU 알고리즘(Least-Frequently-Used) : 참조 횟수가 가장 적은 페이지를 교체하는 방법
                     MFU 알고리즘(Most-Frequently-Used) : 가장 적은 참조 횟수를 가진 페이지가 가장 최근에 사용된 페이지이며, 또 앞으로 사용될 것이라 판단하여 교체하지 않는 방법

      프레임 할당
          여러 프로세스에게 각각 얼마나 많은 프레임을 할당해야할지 결정하는 문제
          프레임 할당에 따라 페이지 부재율이 달라질 수 있기때문에 프레임 할당은 페이지 교체와 더불어 중요하게 작용            
          1. 균등 할당 : 모든 프로세스에게 프레임을 똑같이 할당
          2. 비례 할당 : 각 프로세스의 크기에 맞춰 비율대로 할당
          3. 전역 대 지역 할당             
              전역 교체 : 프로세스가 교체할 프레임을 다른 프로세스에 속한 프레임을 포함한 모든 프레임을 대상으로 찾음
              지역 교체 : 각 프로세스가 자신에게 할당된 프레임 내부에서만 교체될 희생자를 찾음
                       
      쓰레싱(Thrashing)
          만약 한 프로세스가 프레임을 부족하게 할당받는다면 페이지 집합도 부족하게 할당받게 될 것이고, 이는 페이지 부재를 발생시킬 것
          하지만 만약 다른 프로세스들도 모두 열심히 일하고 있는 상황이라 페이지를 내어줄 수 없다면
          다른 프로세스로부터 억지로 페이지를 뺏어오더라도 바로 다시 해당 프로세스가 페이지 부재를 발생시켜 결국 페이지를 되돌려줘야하는 문제가 발생할 수 있다.
          이와 같은 치열한 눈치싸움, 과도한 페이징 작업을 쓰레싱이라 한다.
          쉽게말해 메모리의 페이지 부재율이 높은 상태를 말함. 
          쓰레싱은 어떤 프로세스가 실제 실행보다 더 많은 시간을 페이징에 사용하고 있는 것을 말한다. 쓰레싱이 발생하면 성능은 심각하게 저하됨.     
          실제로 언제 일어나냐면 메모리에 너무 많은 프로세스가 동시에 올라가면 스와핑이 많이 일어나서 발생. 
          쓰레싱은 지역 교환 알고리즘 혹은 우선순위 교환 알고리즘을 적용하여 막을 수 있지만, 좀 더 근본적인 해결책은 각 프로세스가 필요로 하는 최소한의 프레임 수를 보장하는 것이다. 
          이를 위해서는 작업 집합 모델에 대해 이해해야 한다.             
          
          작업 집합 모델(Working-Set Model)
              작업 집합 모델은 프로세스가 필요로 하는 최소한의 프레임 수를 알 수 있는 방법으로, 쓰레싱을 조절하는 방법 중 하나
              작업 집합 모델은 지역성 개념을 기반으로 한다.
          페이지 부재 빈도(PFF, Page-Fault Frequency)
              쓰레싱이 발생했다는 것은 페이지 부재율이 높다는 것을 의미
              페이지 부재율이 높으면 더 많은 프레임이 할당되어야하고, 페이지 부재율이 낮으면 너무 많은 프레임을 할당해 낭비가 될 수 있다.
              단순하게 페이지 부재율의 상한과 하한을 설정. 페이지 부재율이 상한을 넘어가게 되면 해당 프로세스에게 더 많은 프레임을 할당해주면 됨
              또한 하한보다 낮아지게 된다면 해당 프로세스로부터 프레임을 빼앗아 다른 프로세스에게 할당해주면 된다.
                       
                       
