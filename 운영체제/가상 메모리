가상 메모리(Virtual Momory)

  현재 실행중인 코드는 반드시 물리 메모리에 존재해야한다고 생각할 수 있다.
  하지만 모든 코드를 늘 물리 메모리에 올려놓을 필요는 없으며, 그렇게 한다고 할지라도 물리 메모리 크기는 제한적이기 때문에 불가능할 수도 있다.
  이를 해결하기 위해 가상 메모리를 사용한다. 
  가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것. 
  프로그램 중 당장 필요한 일부만을 물리 메모리에 올려놓고 실행하는 것
  
  이점
      프로그램은 물리 메모리 크기에 제약받지 않을 수 있다. 프로그래머들은 매우 큰 가상 주소 공간을 가정하고 프로그래밍을 할 수 있다.
      각 프로그램의 코드 중 일부만이 메모리를 차지하므로 더 많은 프로그램이 동시에 수행될 수 있다. 이는 응답시간의 감소와 CPU 이용률 및 처리율을 향상시킨다.
      프로그램을 메모리에 올리고 스왑할 때 발생하는 입/출력 비용이 감소한다
      페이지 공유를 통해 파일이나 메모리가 둘 이상의 프로세스들에 의해 공유되는 것이 가능. 
      
  요구 페이징
      일반적인 가상 메모리는 보통 요구 페이징으로 구현한다.
      요구 페이징은 프로그램 실행 시 모든 부분을 메모리에 적재하는 것이 아니라, 실행 과정에서 페이지를 요구할 때마다, 즉 페이지들이 필요해질 때마다 적재하는 전략
      요구 페이징은 스와핑과 개념이 유사하다. 스와핑에서는 보조 메모리의 프로세스를 실행하고 싶을 때에 주 메모리로 읽어옴(swap in).
      이와 같이 프로세스 내 페이지를 관리하는 페이저(pager)는 프로세스가 스왑 아웃(swap out)되기 전에 실제로 사용될 페이지가 어떤 것일지 추측하고, 
      이후에는 프로세스 전체를 스왑인 하는 대신 실제 필요한 페이지만 메모리로 읽어온다. 
      이를 위해서는 하드웨어 적인 기술이 필요한데, 유효/무효 비트를 사용하여 페이지가 메모리에 존재할 경우 유효(valid)하다고 표시하고, 
      페이지가 가상 주소 공간에 정의되지 않았거나 디스크에 존재할 경우 무효(invalid)하다고 표시하거나 페이지가 현재 저장된 디스크 주소를 기록한다.
      
      순수 요구 페이징 : 특정 페이지가 필요해 실제로 참조하기 전에는 절대 그 페이지를 메모리로 적재하지 않는 방법
          이를 통해 전체 프로세스가 주 메모리에 올라와있지 않아도 프로세스를 실행할 수 있다.
          메커니즘은 다음과 같다.
              1. 실제로 참조하지 않는 페이지는 초기에 메모리에 올리지 않으므로 어떤 페이지도 메모리에 올라가 있지 않음
              2. 특정 페이지에 대한 참조가 발생
              3. 페이지 부재(page fault) 발생
              4. 운영체제는 내부 테이블을 통해 해당 페이지가 디스크 내부 어디에 위치했는지 파악
              5. 자유 프레임을 탐색하여 디스크로부터 해당 페이지를 읽어옴
              6. 페이지 테이블 내애 페이지에 변화가 생겼음을 표시
              7. 3에서 페이지 부재로 중지되었던 명령이 다시 실행됨
          위에서 볼 수 있듯이 요구 페이징의 성능은 페이지 부재에 의해 좌우됨. 따라서 페이지 부재율을 낮게 유지하는 것이 중요하다.
          
          페이지 교체
               실제 시스템이 보유한 페이지보다 더 많은 프로세스가 더 많은 페이지를 요구할 경우, 페이지 간 교체를 해야하는 문제가 발생
               1. FIFO 페이지 교체(First-In-First-Out)
                   메모리에 올라온 페이지 중 가장 오래된 페이지를 교체하는 방법
                   페이지가 올라온 시간을 기록하거나, 페이지가 올라온 순서대로 큐(queue)를 생성하여 관리
                   가장 직관적이고 단순하지만 성능이 좋지않음
               2. 최적 페이지 교체(OPT, Optimal page replacement)
                   앞으로 가장 오랜 동안 사용되지 않을 페이지를 찾아 교체하는 방법
                   장점 : 가장 낮은 페이지 부재율을 보장하는 최적의 알고리즘
                   단점 : 실제 구현이 거의 불가능
               3. LRU 페이지 교체(Least-Recently-Used)
                   가장 오랜 기간 동안 사용되지 않은 페이지를 교체하는 방법
                   최적 알고리즘의 근사 알고리즘으로 최근의 과거를 가까운 미래의 근사치로 생각
                   각 페이지마다 마지막 사용 시간을 기록하여 구현
                   장점 : OPT와 근사하게 좋은 성능을 보장
                   단점 : 카운터나 스택과 같은 구현을 위해 하드웨어 지원이 필요함
               4. LRU 근사 페이지 교체(LRU Approximation)
                   하드웨어의 지원을 필요로하는 LRU 페이지 교체 알고리즘의 한계를 극복하기 위한 알고리즘
               5. 계수 기반 페이지 교체(Counting-Based)
                     LFU 알고리즘(Least-Frequently-Used) : 참조 횟수가 가장 적은 페이지를 교체하는 방법
                     MFU 알고리즘(Most-Frequently-Used) : 가장 적은 참조 횟수를 가진 페이지가 가장 최근에 사용된 페이지이며, 또 앞으로 사용될 것이라 판단하여 교체하지 않는 방법

      프레임 할당
          여러 프로세스에게 각각 얼마나 많은 프레임을 할당해야할지 결정하는 문제
          프레임 할당에 따라 페이지 부재율이 달라질 수 있기때문에 프레임 할당은 페이지 교체와 더불어 중요하게 작용            
          1. 균등 할당 : 모든 프로세스에게 프레임을 똑같이 할당
          2. 비례 할당 : 각 프로세스의 크기에 맞춰 비율대로 할당
          3. 전역 대 지역 할당             
              전역 교체 : 프로세스가 교체할 프레임을 다른 프로세스에 속한 프레임을 포함한 모든 프레임을 대상으로 찾음
              지역 교체 : 각 프로세스가 자신에게 할당된 프레임 내부에서만 교체될 희생자를 찾음
                       
      쓰레싱(Thrashing)
          만약 한 프로세스가 프레임을 부족하게 할당받는다면 페이지 집합도 부족하게 할당받게 될 것이고, 이는 페이지 부재를 발생시킬 것
          하지만 만약 다른 프로세스들도 모두 열심히 일하고 있는 상황이라 페이지를 내어줄 수 없다면
          다른 프로세스로부터 억지로 페이지를 뺏어오더라도 바로 다시 해당 프로세스가 페이지 부재를 발생시켜 결국 페이지를 되돌려줘야하는 문제가 발생할 수 있다.
          이와 같은 치열한 눈치싸움, 과도한 페이징 작업을 쓰레싱이라 한다.
          쓰레싱은 어떤 프로세스가 실제 실행보다 더 많은 시간을 페이징에 사용하고 있는 것을 말한다. 쓰레싱이 발생하면 성능은 심각하게 저하됨.             
          쓰레싱은 지역 교환 알고리즘 혹은 우선순위 교환 알고리즘을 적용하여 막을 수 있지만, 좀 더 근본적인 해결책은 각 프로세스가 필요로 하는 최소한의 프레임 수를 보장하는 것이다. 
          이를 위해서는 작업 집합 모델에 대해 이해해야 한다.             
          
          작업 집합 모델(Working-Set Model)
              작업 집합 모델은 프로세스가 필요로 하는 최소한의 프레임 수를 알 수 있는 방법으로, 쓰레싱을 조절하는 방법 중 하나
              작업 집합 모델은 지역성 개념을 기반으로 한다.
          페이지 부재 빈도(PFF, Page-Fault Frequency)
              쓰레싱이 발생했다는 것은 페이지 부재율이 높다는 것을 의미
              페이지 부재율이 높으면 더 많은 프레임이 할당되어야하고, 페이지 부재율이 낮으면 너무 많은 프레임을 할당해 낭비가 될 수 있다.
              단순하게 페이지 부재율의 상한과 하한을 설정. 페이지 부재율이 상한을 넘어가게 되면 해당 프로세스에게 더 많은 프레임을 할당해주면 됨
              또한 하한보다 낮아지게 된다면 해당 프로세스로부터 프레임을 빼앗아 다른 프로세스에게 할당해주면 된다.
                       
                       
