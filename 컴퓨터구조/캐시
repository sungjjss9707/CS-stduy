컴퓨터 시스템의 성능을 향상시키기 위해 별도로 탑재된 캐시 전용 메모리.

레지스터, 메인 메모리와 함께 메모리 계층 구조의 전통적인 핵심 계층 중 하나이다. 
프로그램에서 직접적으로 읽거나 쓸 수 없고 하드웨어의 메모리 관리 시스템이 내부적으로 제어한다. 
대부분 프로그램은 한번 사용한 데이터를 재사용할 가능성이 높고, 그 주변의 데이터도 곧 사용할 가능성이 높은 데이터 지역성을 가지고 있다.
데이터 지역성을 활용하여 메인 메모리에 있는 데이터를 캐시 메모리에 불러와 두고, 프로세서가 필요한 데이터를 캐시 메모리에서 먼저 찾도록 하면 시스템 성능을 향상시킬 수 있다.


프로세서의 클럭 속도가 매우 빨라짐에 따라 프로세서 밖에 있는 메인 메모리와의 속도 차이가 현저하게 증가하였는데,
이 때문에 프로세서 클럭 속도를 아무리 올려도 메인 메모리에서 데이터를 빠르게 제공해 주지 못하여 전체 시스템 성능이 증가하기 어렵게 되었다.

작동 원리 : 데이터 지역성
    시간지역성 : for나 while 같은 반복문에 사용하는 조건 변수 i 처럼 한번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높다
    공간지역성 : A[0], A[1]과 같은 데이터 배열에 연속으로 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후에 사용될 가능성이 높다
    
캐시의 목표
    캐시 적중률의 최대화 & 부적중률(不的中律)의 최소화
    캐시 정책 및 알고리즘의 최적화
    캐시 레이턴시의 최소화
    캐시 대역폭의 최대화
    
    
    캐시적중(히트)vs캐시부적중(미스)
        CPU가 데이터를 요청하여 캐시 메모리에 접근했을 때 캐시 메모리가 해당 데이터를 가지고 있다면 이를 '캐시 적중(cache hit)'이라고 부르고, 
        해당 데이터가 없어서 DRAM에서 가져와야 한다면 '캐시 부적중(cache miss)'라 부른다.
        캐시 적중이 일어나면 해당 데이터를 CU를 거쳐서 갖고온다. 이경우 위치도 가깝고 CPU내부 버스를 이용하기때문에 상당히 빠름
        캐시 부적중할 경우의 처리 방법은 캐시 정책에 따라 다르다. 
        캐시 적중의 정도를 나타내는 지표가 캐시 적중률(cache hit ratio)임. (캐시 히트 횟수)/(전체 요청 횟수)*100 임.
        캐시 부적중의 종류
            1. Compulsory miss(또는 Cold miss): 해당 메모리 주소를 처음 불렀기 때문에 나는 미스.
                예를 들어 프로그램을 새로 켜거나 하는 경우 발생한다.
                사실상 예방이 불가능한 캐시 미스지만, 전체 컴퓨터 이용 시간에 비하면 굉장히 드물게 나는 미스 유형이라 
                전체적인 성능에 영향을 미치는 정도는 작다.
            2. Conflict miss: 캐시 메모리에 A 데이터와 B 데이터를 저장해야 하는데, A와 B가 같은 캐시 메모리 주소에 할당되어서 나는 캐시 미스다.
            3. Capacity miss: 캐시 메모리에 공간이 부족해서 나는 캐시 미스. 캐시 크기를 키우면 해결되지만, 
                캐시 크기를 키우면 캐시 접근속도가 느려지고 파워를 많이 먹는다는 단점이 생긴다.
        *캐시 적중 실패율이 단순 작업 기준으로 평균 10% 안쪽이기 때문에 캐시 메모리를 통해 컴퓨터 시스템의 평균 성능을 크게 향상시킬 수 있 
        
        
    캐시 정책 및 알고리즘
        캐시 메모리 성능 향상에 있어서 적절한 캐시 정책 및 알고리즘을 취해야 유효 레이턴시를 최소화하면서 유효 대역폭을 끌어 올릴 수 있다.
        캐시는 주기억장치보다 용량이 매우 작으므로 캐시를 주기억장치에 어떻게 매핑 시키느냐가 중요한 관건임. 
        1. 직접매핑 : MM 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일(n:1) 방식이다. MM의 1~10을 캐시1에, MM의 10~20을 캐시2에 
            순서대로 넣는 방식이라고 생각하면 됨. 처리가 빠르지만 충돌이 자주 발생한다.(Locality를 신경 안썼기 때문) 요샌 거의 안쓰임
        2. 연관매핑 : 순서를 일치시키지 않고 비어있는 캐시가 있으면 마음대로 주소를 저장함. 때문에 locality 가 좋음. 
            근데 찾을때 일일이 찾아서 검샤해야해서 느림. 
        3. 집합연관매핑 : 위 두개의 장점을 섞음. 특정 행을 지정해서 그 행 안의 어떤 열이든 비어있으면 저장하는 방식이다. 
            당연히 Direct에 비해서는 검색은 오래 걸리지만 저장이 빠르며, Associative에 비해 저장이 느린 대신 검색이 빠른 중간적인 특징이라고 할 수 있다.
            요새 왠만하면 이거 쓰임
            
  l1, l2, l3캐시
      L1에서 순차적으로 데이터를 찾아 L1에 찾고자 하는 데이터가 없다면 순서대로 L2, L3로 올라가며 데이터를 찾는다.
      L1 <------------------> L3
      속도빠름            속도느림
      용량작음             용량큼
