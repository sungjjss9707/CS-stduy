CISC

  Complex Instruction Set Computer
  종류가 다양하고 하는 일이 복잡한 명령어로 이루어진 CPU, 또는 마이크로프로세서.
  
  특징 : 
      명령어의 길이가 가변적이기 때문에 명령어 밀도에서 유리한 편이다. 만약 데이터나 주소값이 필요하다면 명령어 길이를 늘려 해결한다. 
      하지만 RISC 구조에서는 길이를 늘릴 수도 없고 정해진 명령어 워드 길이 안에서 해결해야 한다. 
      그래서 복잡하다는 편견과 달리 CISC 구조는 명령어 세트 설계가 바이트 단위로 깔끔한 편이다.
      흔히 비파이프라이닝 방식을 사용하는데, 이 방식은 명령어를 하나씩 처리하는 방식으로 한 명령어가 끝나야 다음 명령어를 처리하므로 
      명령어를 쪼개서 한번에 여러개를 동시에 처리하는 파이프라이닝 방식에 비해서 비효율적이다.
      파이프라이닝 방식을 적용하기 위해서는 명령어 사이의 데이터 흐름을 실시간으로 분석해야 하는데 명령어가 복잡하면 
      이 분석에 사용되는 하드웨어가 너무 복잡해져서 설계 비용이 증가하고 회로의 속도가 떨어지기 때문에 CISC에서는 폭넓게 적용하기가 매우 어렵다.
      이 때문에 성능 향상이 나중에 나온 RISC에 따라잡히게 되면서 현재는 도태되었고 결국 100% 온전한 의미의 CISC 프로세서는 현재 시장에서 찾아볼 수 없다
      
  장점 : 
      1. 작지만 고밀도의 코드를 사용 : 하나의 마이크로코드에 많은 명령어들을 담아내므로 코드의 밀도가 높다.
           CISC를 사용하면 프로그램의 용량을 줄일 수 있고 메모리 접근 횟수를 크게 줄일 수 있다. CISC의 장점은 바로 적은 지시로 많은 작업을 처리할 수 있단 점이다. 
      2. 생산성이 높다(마이크로코드 작성이 쉽다) : 코드 단위당 작업량이 매우 많다
      3. 호환 명령어 : RISC는 CPU 구조가 바뀌어 처리 비트 단위에 변화가 생기면 기존의 명령어를 사용할 수 없어 호환성의 문제를 일으킨다. 
          CISC는 구조상 프로세싱 단계에 꼭 들어맞아야 할 최적 명령어의 개념이 없어, 하드웨어 단계에서 지원하는 명령어를 후속 프로세서에서도 지원해준다면 명령어의 호환성을 크게 신경쓰지 않아도 된다.
  단점 : 
      1. 구조가 복잡해 프로세서 설계가 힘들다 : RISC를 탄생시킨 결정적인 이유이다. 마이크로코드를 받으면 이를 해독해야 하는데, 
          해독 자체도 어려워 디코더 설계가 까다로우며 해독한 뒤에는 버퍼를 거쳐 명령어를 재정렬 해야하는 등 시퀀싱도 복잡하다.
      2. 파이프라이닝 구현이 매우 어렵다 : 일정한 길이로 작게 쪼개진 마이크로코드를 사용하는 RISC는 코드를 바로 파이프라인에 투입하면 되므로 파이프라이닝 구현이 쉽다
          CISC는 어떤 길이의 마이크로코드가 입력될지 알 수 없기 때문에 이를 적절하게 쪼개 파이프라인으로 전달해줘야 해, 파이프라이닝 구현이 RISC에 비해 난해하다. 
      3. 특정 환경에서 RISC보다 비효율적 : 코드의 과대포장의 문제이다. RISC로 절제해 입력할 수 있는 마이크로코드를, 그것도 CISC에서는 이상적으로만 작성한다면 
          더 간단하게 입력할 수 있는 코드를 인적인 문제 때문에 과도하게 크게 만들어 성능을 저하시키는 문제이다. 
          CISC는 코드 길이를 가변적으로 입력할 수 있기에, 프로그래머의 실력이 떨어지면 코드를 필요 이상으로 길게 작성하는 일이 발생해 큰 퍼포먼스 저하를 유발할 수 있다
      4. 디코더가 비대해짐 : 마이크로코드를 해독해야 하는 디코더가 굉장히 비대해진다.
          지금은 반도체 공정의 발전으로 트랜지스터를 늘리기 쉽지만, 예전에는 프로세서의 가용 트랜지스터 수가 굉장히 제한적이었다. 
          그런데 CISC는 디코딩이 복잡해 CISC 프로세서의 디코더가 커질 수 밖에 없어 많은 트랜지스터를 디코더가 혼자 독식하는 일이 비일비재함.
