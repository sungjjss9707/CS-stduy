버블정렬

  1번째와 2번째 원소를 비교해서 정렬, 2번째 3번째를 비교해서 정렬, ... , n-1번째와 n번째를 비교해서 정렬해서 끝까지 하면 마지막 n번 자리엔 제일큰게 위치하게 된다.
  그다음엔 1부터 n-1번째까지 정렬해서 n-1자리에 그다음 큰 원소를 위치시키고 이 행위를 n번 해주면 모든 원소가 정렬이 된다.
  *시간복잡도 : n(n-1)/2
  *특징 : 거의 모든 상황에서 최악의 성능을 보여준다.
          구현하기에 손쉽지만 비효율적이기 때문에 실제 개발에선 쓰이지 않는다.
  *코드 : 
  void bubble_sort(){
	  int i,k, temp;
	  for(i=len-1; i>=0; --i){
      	for(k=0; k<i; ++k){
        		if(arr[k]>arr[k+1]) {
      	  		temp = arr[k+1]; 
				      arr[k+1] = arr[k]; 
				      arr[k] = temp;	  
	  		    } 
    	  }
  	  }
  }
          
선택정렬

  1번째부터 끝까지 훑어서 가장 작은게 1번째, 2번째부터 끝까지 훑어서 그다음 작은게 두번째..이렇게 끝까지 해서 모두 정렬한다.
  *시간복잡도 : n(n-1)/2
  *코드 : 
  void select_sort(){
	  int i,k, temp;
	  for(i=0; i<len-1; ++i){
    	for(k=i+1; k<len; ++k){
      		if(arr[i]>arr[k]){
      			temp = arr[k];
			    	arr[k] = arr[i]; 
			    	arr[i] = temp;
	  		  } 
    	  }
    	}
  }
  
삽입정렬

  k번째 원소를 이미 정렬돼있는 1~k-1의 범위와 하나하나씩 비교해가면서 적적한곳에 집어넣고 그 뒤로는 한칸씩 밀어버리는 알고리즘
  *시간복잡도 : n(n-1)/2
  *특징 : o(n^2)의 시간복잡도를 가지는 버블, 선택, 삽입 중에선 제일 빠름. 배열의 크기가 작을땐 nlogn보다 효율적일때도 있음
            -> 그렇기 때문에 보통 개발할때 배열크기가 크면 nlogn 정렬 쓰다가 작은 경우엔 삽입정렬 쓰기도 함
  *코드 : 
  void insert_sort(){
	int i,k, temp;
	for(i=1; i<len; ++i){
    for(k=i; k>0; --k){
      if(arr[k]<arr[k-1]){
        temp = arr[k]; 
		    arr[k] = arr[k-1]; 
		    arr[k-1] = temp;
      }
      else  break;
    }
  }
}
  
  
