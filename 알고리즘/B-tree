B-tree

  일반적인 트리 구조인 이진 트리에서 확장되어 부모가 더 많은 수의 자식을 가질 수 있음.
  M개의 자식을 가질 수 있도록 설계된 경우, M차 B-트리라고 한다.
  하나의 레벨에 많은 자료가 저장되기 때문에 전체적으로 트리의 높이가 줄어들게 됩니다.
  트리의 높이가 줄어든다는 것은 곧 트리의 성능이 높아진다는 것을 의미(log 단위로 성능함)
  또한 이런식으로 구성된 트리는 always 균형 잡힌 트리가 되어 검색에서든, 삽입에서든, 삭제에서든 항상 O(logN)의 성능을 보장
  하나의 노드에 이렇게 많은 데이터를 가질 수 있다는 것은 대량의 데이터 처리가 필요한 검색 구조에 큰 장점이 됨.
  데이터베이스 시스템의 인덱스 저장 방식으로 유용하게 쓰입니다. 대신에 트리 특성상 순회작업이 어렵다.
  
  특징 : 노드는 최대 M개 부터 M/2개 까지의 자식을 가질 수 있다.
         노드에는 최대 M−1개 부터 [M/2]−1개의 키가 포함될 수 있다.
         노드의 키가 x개라면 자식의 수는 x+1개 이다.
         key값의 왼쪽자식들은 항상 key보다 작은값들을, 오른쪽자식들은 항상 큰값들을 가진다.
         
                        10 20                             차수:1
                         
              5         14 17          23 27              차수:2
                  
             3 7    11 12    15 18    22 25 30            차수:3
          
          검색프로세스(18 검색) : => 하향식
            1. 차수1일때부터 시작한다. 18은 10과 20의 사이이기 때문에 차수 2의 가운데 노드로 간다.
            2. 18은 17보다 크기때문에 차수3의 3번째노드(15 18)로 간다.
            3. 18찾음
            4. 리프노드까지 왔는데 못찾으면 없는거임
            
          삽입프로세스 : key를 삽입하기 위해서는 요소 삽입에 적절한 리프노드를 검색하고 필요한 경우 노드를 분할해야함(삽입은 상향식임)
            1. 트리가 비어있으면 루트노드를 할당하고 k삽입. 만일 루트노드가 가득찼다면 노드를 분할하고 리프노드 생성
            2. 이후에는 삽입하기에 적절한 리프노드를 찾아 k를 삽입. 
            
          삭제프로세스 :
            1. 삭제할 키가 있는 노드 검색
            2. 키 삭제
            3. 필요한 경우, 트리 균형 조정
            
            
            
B+tree
  
  B-트리는 특성상 순회 작업이 상당히 난감하다. B+ 트리는 색인구조에서 순차접근에 대한 문제의 해결책으로 제시되었다.
  B-트리에서는 특정 key 값이 하나의 노드에서만 존재할 수 있지만 B+ 트리에서는 leaf 노드와 leaf의 부모 노드에서 공존할 수 있다.
  왜냐하면 B+ 트리의 비단말 노드(not leaf)들은 데이터의 빠른 접근을 위한 인덱스 역할만 하기 때문. (index set 이라 불린다)
   leaf 노드들은 연결 리스트 형태로 서로 연결되어 있고 이를 순차집합(sequence set)이라고 하며 오름차순으로 정렬이 되어 있습니다.
           
  
  
   
