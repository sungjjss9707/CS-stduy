해시테이블

  해시테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있다.
  해시테이블이 빠른 검색속도를 제공하는 이유는 내부적으로 배열을 사용하여 데이터를 저장하기 때문이다.
  배열의 index만 알면 검색속도가 O(1)이다. 
  사람의 전화번호를 저장하는 해시테이블이 있다고 가정하면
    hast_table["준혁"] = "123-4567";
    hast_table["종신"] = "987-6543";
    hast_table["은희"] = "777-7777";
  처럼 저장될거고 전화번호 배열 arr은
    arr[0] =  "987-6543";
    arr[1] = "123-4567";
    arr[2] = "777-7777";
  처럼 저장된다고 가정하자 
  "준혁", "종신", "은희" 라는 string을 인덱스 0,1,2 로 바꾸는 함수가 존재해야한다. 그것을 해시함수라고 한다.
  ==>그니까 중요한게 해시테이블은 (key, value)의 페어인데 key값을 고유한 index로 매칭시키는게 중요함
  

해시함수
  
  해시 함수에서 중요한 것은 고유한 인덱스 값을 설정하는 것이다.
  충분히 확인되지 않은 어설픈 해시 함수를 사용해 key 값들을 결정한다면 동일한 값이 도출될 수 있다.
  이렇게 되면 동일한 key 값에 복수개의 데이터가 하나의 해시 배열에 존재할 수 있게 되는 것인데
  이를 '충돌'(collision)이라고 한다.
  즉, 충돌은 서로 다른 두 개의 키가 같은 인덱스로 hashing되면 같은 곳에 저장할 수 없게 되는 것을 말한다.
  해시 함수를 무조건 1:1로 만드는 것보다 충돌을 최소화하는 방향으로 설계하고, 발생하는 충돌에 대비해서 어떻게 대응할 것인가가 더 중요하다. 
  1:1 대응이도록 만드는 것이 거의 불가능하기도 하고 그런 해시 함수를 만든다면 보통의 배열과 다를바 없고 메모리를 너무 차지하게 된다.
  충돌이 많아질수록 검색에 필요한 시간복잡도가 O(1)에서 O(N)에 가까워진다. 어설픈 해시 함수는 해시를 해시답게 사용하지 못하도록 한다. 
  좋은 해시 함수를 선택하는 것은 hash table 의 성능 향상에 필수적인 것이다. 
  따라서 hashing된 인덱스에 이미 다른 값이 들어 있다면 새 데이터를 저장할 다른 위치를 찾은 뒤에 저장할 수 있는 것이다. 따라서 충돌 해결은 필수이다.

    충돌대응법
      1. 개방주소법(Open Address 방식) : 해시 충돌이 발생하면 해시함수로 얻은 주소가 아닌 다른 주소에 자료를 삽입하는 방식이다
        *선형조사 : 충돌이 일어난뒤 한칸씩 뒤로가면서 저장해줌
        *제곱조사 : 충돌이 일어나면 key를 제곱해서 비어있는 버킷을 찾는다.
        *Double Hashing : 한번해시해서 충돌이 일어나면 2차 해시를 이용해서 새로운 주소를 할당한다.
 
 
hash_map
  
  c++에는 set, map이 있는데 얘네는 값을 삽입하면 정렬돼서 저장된다. 그래서 검색할때는 이분탐색으로 검색하기 때문에
  logn의 시간이 걸린다.
  hash_map, hash_set 는 정렬하지 않고 저장한다. 그리고 컴파일러 별도의 해시함수를 이용해서 바로 인덱스를 도출하기때문에
  이론적으로 검색에 O(1)의 시간이 걸린다. => 근데 표준 STL이 아님
  그리고 삽입, 삭제가 빈번하게 일어나지 않는데서 쓰는게 좋음
  
  
  
