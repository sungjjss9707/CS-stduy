트리

  계층적인 구조의 자료를 표현하는 비선형 자료구조
  *트리관련 용어 :
    루트(root) : 계층적인 구조에서 가장 높은 곳에 있는 노드. 한 트리에는 하나의 루트만이 존재한다.
    리프(leaf, 단말 노드) : 자식 노드가 존재하지 않는, 더 이상 아래로 뻗어나갈 수 없는 노드
    부모(parent) : 현재 노드에서 간선으로 연결된 위쪽에 있는 노드. 트리의 각 노드는 무조건 1개의 부모 노드만 가질 수 있다.
    자식(child) : 현재 노드에서 가지로 연결된 아래쪽 노드. 트리의 각 노드는 자식 노드를 가지지 않을 수도, 여러개의 자식 노드를 가질 수도 있다.
    형제(sibling) : 부모 노드가 동일한 노드들
    조상(ancestor) : 현재 노드에서 간선을 따라 루트노드까지 올라갈 때 연결된 모든 노드
    자손(descendant) : 서브 트리에 있는 하위 레벨의 노드들
    서브 트리(subtree) : 부모 노드와 연결된 간선을 끊으면 새롭게 생성되는 트리. 하나의 트리는 여러개의 서브 트리를 포함하고 있다.
    레벨(level)과 높이(height) : 루트 노드로부터 현재 노드에 이르기까지 연결된 간선의 수.(노드들의 레벨의 최댓값 : 트리의 높이).
    차수(degree) : 현재 노드에 연결된 자식 노드의 수. 트리의 차수는 트리의 차수의 최댓값이다.
    
    
    
  이진 트리(Binary Tree) : 모든 노드가 2개의 서브 트리를 가지고 있는 트리.
      특징 : 
          모든 노드는 왼쪽 자식 노드와 오른쪽 자식 노드를 각각 1개씩, 최대 2개의 노드만을 자식 노드로 가질 수 있다.(최대 차수 2)
          공집합도 이진트리이다.
          서브 트리 간 순서(왼쪽, 오른쪽)가 존재한다.
          노드의 개수가 n개인 이진트리의 간선 개수는 n-1개
          높이가 h인 이진트리의 최소 노드 개수는 h+1개, 최대 노드 개수는 2^(h+1) - 1개
          
    
    포화 이진 트리(Full Binary Tree)
      모든 높이에 노드가 최대로 차 있는 이진 트리
      따라서 노드 개수는 이진 트리의 최대 노드 개수인 2^(h+1) - 1개
      루트 노드를 1번으로 하여 모든 노드가 순서대로 노드 번호를 가진다.
      
    완전 이진 트리(Complete Binary Tree)
      루트 노드를 1번으로 하여 n개의 노드를 갖는 이진 트리에서 1번부터 n번까지 빈 자리가 없는 이진 트리
      제일 마지막 부분은 full하지 않아도 된다.
      낮은 높이에서 시작하여 왼쪽 자식 노드부터 채워야 한다.
      
    편향 이진 트리(Skewed Binary Tree)
      높이 h에 대한 최소 개수의 노드를 가지며 한 쪽 방향의 자식 노드만을 가진 이진 트리(그냥 일자로 쭉 이어짐)
      따라서 노드 개수는 이진 트리의 최소 노드 개수인 h+1개
      
  
  
  이진 트리의 구현
  
      배열을 이용한 표현
          n개의 노드를 갖는 이진 트리의 경우 루트 노드부터 마지막 노드까지 1번 ~ n번 번호를 매긴 뒤, 배열의 1번 인덱스부터 n번 인덱스까지 순서대로 노드를 삽입하여 구현
          높이가 h인 이진 트리를 구현하기 위해서는 배열의 크기가 2^(h+1)가 되어야 한다.
          배열의 1번 인덱스부터 사용하므로 이진 트리의 최대 노드 개수인 2^(h+1) - 1개보다 1개 많은 크기임
          트리의 1번 노드를 배열 arr[1]에 삽입하고 트리의 2번노드를 arr[2]에, 3번을 arr[3]에, 
          4번노드를 arr[4]에, 5번노드를 arr[5]에, 6번노드를 arr[6]에, 7번노드를 arr[7]에....
          k번노드를 arr[k]에 삽입함. arr[k]의 자식노드는 arr[2*k]랑, arr[2*k+1]임
          배열을 이용한 이진 트리는 구현이 쉽지만, 배열 원소에 대한 메모리 공간 낭비가 발생할 수 있다.
          편향 이진  트리의 경우 띄엄띄엄 저장하게 되므로 사용하지 않는 배열의 영역이 많아진다.
          트리의 중간에 새로운 노드를 삽입하거나 삭제할 경우 배열의 크기 변경이 어려워 비효율적이다.
      
      링크를 이용한 표현
          이진 트리 노드 번호 성질을 이용해 각 부모 노드에 왼쪽 자식 노드와 오른쪽 자식 노드를 연결하여 표현한다. 한 노드가 두 개의 링크 필드를 갖는 형태이다.
          노드 번호가 i인 노드의 부모 노드 번호 : i/2
          노드 번호가 i인 노드의 왼쪽 자식 노드 번호 : 2*i
          노드 번호가 i인 노드의 오른쪽 자식 노드 번호 : 2*i + 1
          레벨 n인 노드의 시작 번호 : 2^n
          배열 표현법의 한계인 메모리 낭비를 막을 수 있다. 이진 트리의 노드 개수만큼 노드를 생성하면 된다.
          특정 노드를 탐색하기 위해 루트 노드부터 탐색을 시작해야 하므로 탐색이 비효율적이다.
          
         
    트리의 탐색
        너비우선탐색, 깊이우선탐색이 있음
        
    트리의 순회 (노드방문을 기준으로 생각하면 편함. 노드방문을 제일처음하면 전위임)
        전위순회 : 노드방문 -> 왼쪽자식 -> 오른쪽자식
        중위순회 : 왼쪽자식 -> 노드방문 -> 오른쪽자식
        후위순회 : 왼쪽자식 -> 오른쪽자식 -> 노드방문
        
        
        
    이진탐색트리
        이진트리이긴 한데 자신의 왼쪽 자손들은 자기보다 작은애들, 오른쪽 자손들은 자기보다 큰애들을 위치시켜서 2진탐색하기 편하게 만들어 논것
        특징 : 
            모든 노드의 키(Key)는 유일하다
            왼쪽 서브 트리의 키들은 루트의 키보다 작다.
            오른쪽 서브 트리의 키들은 루트의 키보다 크다.
            왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.
            이진 탐색 트리는 이진 암호화, 파일 시스템에 주로 쓰임
            
        검색 : 지금노드보다 큰값이면 오른쪽자식, 작은값이면 왼쪽자식으로 내려가면서 찾음
        삽입 : 검색과비슷하게 계속 값 비교하면서 내려가다가 적당한 리프노드에 삽입해버리면 됨
        삭제 : 삭제할 노드가 리프면 그냥 삭제하면 끝
               아니라면 그 값을 삭제한다음에 규칙맞게 값들을 재조정해야함
                  (규칙 : 루트의 왼쪽 서브트리의 가장 오른쪽 값은 루트보다 작은 가장 가까운 수이며, 오른쪽 서브트리 의 가장 왼쪽 값은 루트보다 큰 가장 가까운 수)
                  
        시간복잡도 : 겁색, 삽입, 삭제 모두 균형상태이면 O(logN), 불균형 상태라면 최대 O(N) ㅇㅣㅁ.
